'use server'

import { connectToDatabase } from "./mongodb";
import { ObjectId, type DeleteResult } from "mongodb";

export interface Influencer {
  id: string;
  name: string;
  handle: string;
  channelId: string;
}

export interface Post {
  /** The unique identifier for the post, generated by MongoDB. This is automatically created on insertion. */
  id: string;
  /** The channel ID of the influencer who created the post. Must match a 'channelId' from the 'influencers' collection. */
  channelId: string;
  /** The title of the post (e.g., YouTube video title). */
  title: string;
  /** The publication date of the post in ISO 8601 format string (e.g., "2024-07-21T18:30:00Z"). */
  isoDate: string;
  /** The URL link to the original post/video. */
  link?: string;
  /** The transcript or summary of the post's content. Can be added or updated later. */
  transcript?: string;
}

export interface Trend {
  /** The unique identifier for the trend, generated by MongoDB. This is automatically created on insertion. */
  id: string;
  /** The text content of the generated trend summary. */
  summary: string;
  /** The creation date of the trend in ISO 8601 format string. */
  createdAt: string;
}

const mapMongoDoc = (doc: any) => {
  if (!doc) return null;
  const { _id, ...rest } = doc;
  return { id: _id.toHexString(), ...rest };
};

export const getInfluencers = async (): Promise<Influencer[]> => {
  const db = await connectToDatabase();
  const influencers = await db.collection("influencers").find({}).sort({ name: 1 }).toArray();
  return influencers.map(mapMongoDoc) as Influencer[];
};

export const getInfluencerById = async (id: string): Promise<Influencer | null> => {
  if (!ObjectId.isValid(id)) return null;
  const db = await connectToDatabase();
  const influencer = await db.collection("influencers").findOne({ _id: new ObjectId(id) });
  return mapMongoDoc(influencer) as Influencer | null;
};

export const addInfluencer = async (influencer: Omit<Influencer, 'id'>): Promise<Influencer> => {
  const db = await connectToDatabase();
  const result = await db.collection("influencers").insertOne(influencer);
  return { ...influencer, id: result.insertedId.toHexString() };
};

export const updateInfluencer = async (id: string, data: Partial<Omit<Influencer, 'id'>>): Promise<Influencer | undefined> => {
    if (!ObjectId.isValid(id)) return undefined;
    const db = await connectToDatabase();
    const result = await db.collection("influencers").findOneAndUpdate(
      { _id: new ObjectId(id) },
      { $set: data },
      { returnDocument: 'after' }
    );
    return mapMongoDoc(result) as Influencer | undefined;
};

export const deleteInfluencer = async (id: string): Promise<DeleteResult> => {
    if (!ObjectId.isValid(id)) return { acknowledged: false, deletedCount: 0 };
    const db = await connectToDatabase();
    
    const influencer = await db.collection("influencers").findOne({ _id: new ObjectId(id) });
    if (!influencer) {
        return { acknowledged: true, deletedCount: 0 };
    }

    await db.collection("posts").deleteMany({ channelId: influencer.channelId });
    
    return await db.collection("influencers").deleteOne({ _id: new ObjectId(id) });
};

export const getPosts = async (): Promise<Post[]> => {
  const db = await connectToDatabase();
  const posts = await db.collection("posts").find({}).sort({ isoDate: -1 }).limit(20).toArray();
  return posts.map(mapMongoDoc) as Post[];
};

export const getAllPostsForTrend = async (): Promise<string> => {
  const allPosts = await getPosts();
  if (allPosts.length === 0) return "";
  
  const allInfluencers = await getInfluencers();
  const influencerMap = new Map(allInfluencers.map(i => [i.channelId, i.name]));

  const postTitles = allPosts
    .map(p => `Content from ${influencerMap.get(p.channelId) || 'Unknown'}: ${p.title}`).join('\n');
  return postTitles;
};


export const getLatestTrend = async (): Promise<Trend | null> => {
  const db = await connectToDatabase();
  const latestTrend = await db.collection("trends").find().sort({ createdAt: -1 }).limit(1).toArray();
  if (latestTrend.length === 0) return null;
  return mapMongoDoc(latestTrend[0]) as Trend | null;
};

export const addTrend = async (summary: string): Promise<Trend> => {
  const db = await connectToDatabase();
  const newTrend = {
    summary,
    createdAt: new Date().toISOString()
  };
  const result = await db.collection("trends").insertOne(newTrend);
  return { ...newTrend, id: result.insertedId.toHexString() };
};
